<!DOCTYPE html>
<html lang="en">

<head>
	<title>Memories</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

	<style>
		html,
		body {
			background: #111;
			color: #fff;
			padding: 0;
			margin: 0px;
			font-weight: bold;
			overflow: hidden;
			display: block;
		}

		#panel {
			position: absolute;
			top: 0%;
			left: 0%;
			width: 160px;
		}
	</style>
</head>

<body>


	<div id="container"></div>

	<script type="importmap">
		{
			"imports": {
				"three": "./build/three.module.js",
				"three/addons/": "./jsm/"
			}
		}
	</script>

	<script type="module">
		import * as THREE from 'three'
		import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js'
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
		import { Olta } from './olta.module.js'

		var scene, controls, renderer, camera, stats
		var model, skeleton, mixer, clock
		var actions, settings

		let currentClip = 0

		const olta = Olta()

		const updateHandler = () => {
			if (!actions) {
				return
			}

			const docs = olta.getAll("action")?.map((action) => parseBigInt(action.value))
			actions.forEach(action => {
				action.stop()
			})

			currentClip = Number(docs[0])
			actions[docs[0]].play()
		}

		olta.onUpdate(updateHandler)

		window.addEventListener('dblclick', () => {
			const max = olta.getAll("action")?.length + 1
			const value = `${currentClip === max ? 0 : currentClip + 1}n`

			olta.update("action", {
				id: "0",
				value
			})
		})

		init()

		function init() {
			const container = document.getElementById('container')
			camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 100)
			camera.position.set(-4, 1, -9)

			clock = new THREE.Clock()
			scene = new THREE.Scene()

			scene.background = new THREE.Color(0xa0a0a0)
			scene.fog = new THREE.Fog(0xa0a0a0, 1, 20)

			// LIGHTS
			var hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 3)
			hemiLight.color.setHSL(0.6, 1, 0.1)
			hemiLight.groundColor.setHSL(0.1, .1, 0.6)
			hemiLight.position.set(10, 70, 10)
			hemiLight.rotation.set(0, -30, 0)
			scene.add(hemiLight)
			// var hemiLightHelper = new THREE.HemisphereLightHelper( hemiLight, 1 );
			// scene.add( hemiLightHelper );

			var dirLight = new THREE.DirectionalLight(0xffffff, 1)
			dirLight.color.setHSL(0.1, .5, 1)
			dirLight.position.set(-5, 6, .01)
			dirLight.position.multiplyScalar(12)
			scene.add(dirLight)
			dirLight.castShadow = true
			dirLight.shadow.mapSize.width = 512
			dirLight.shadow.mapSize.height = 512
			dirLight.intensity = 0.4

			var d = 20
			dirLight.shadow.camera.left = -d
			dirLight.shadow.camera.right = d
			dirLight.shadow.camera.top = d
			dirLight.shadow.camera.bottom = -d
			dirLight.shadow.camera.far = 150
			dirLight.shadow.bias = -0.00001
			// var dirLightHeper = new THREE.DirectionalLightHelper( dirLight, 10 );
			// scene.add( dirLightHeper );

			// Ground
			var mesh = new THREE.Mesh(new THREE.CircleGeometry(40, 40), new THREE.MeshPhongMaterial({
				color: 0x999999, depthWrite: true
			}))
			mesh.rotation.x = - Math.PI / 2
			mesh.position.y = -2.05
			mesh.receiveShadow = true
			scene.add(mesh)

			// 3D Model
			var loader = new GLTFLoader()
			loader.load('./gltf/Memories_animClips_V14.gltf', function (gltf) {

				var model = gltf.scene
				gltf.scene.traverse(function (object) {

					if (object.isMesh) {

						//   console.log(object.name)
						var m = object.material

						m.transparent = true
						m.opacity = 0.5
						m.DoubleSided = true
						object.material = object.material.clone()

						const rColor = () => Math.floor((Math.random() * 255))
						object.material.color = new THREE.Color(`rgb(${rColor()}, ${rColor()}, ${rColor()})`)
						object.castShadow = true
						object.receiveShadow = true
					}

					model.position.set(0, -2.2, 0)
					model.rotation.set(0, -3.1, 0)
					model.scale.set(.025, .025, .025)
					scene.add(model)
				})


				// Skeleton
				skeleton = new THREE.SkeletonHelper(model)
				skeleton.visible = false
				scene.add(skeleton)

				mixer = new THREE.AnimationMixer(model)
				actions = gltf.animations.map((animation) => mixer.clipAction(animation))

				updateHandler()
				animate()
			})

			// Rendering	
			renderer = new THREE.WebGLRenderer({ antialias: true })
			renderer.setPixelRatio(window.devicePixelRatio)
			renderer.setSize(window.innerWidth, window.innerHeight)
			renderer.outputEncoding = THREE.sRGBEncoding
			renderer.toneMapping = THREE.ReinhardToneMapping
			//renderer.shadowMap.enabled = true;
			container.appendChild(renderer.domElement)
			renderer.shadowMap.enabled = true
			renderer.shadowMap.type = THREE.PCFSoftShadowMap

			// Event Listeners	
			window.addEventListener('resize', onWindowResize, false)
			// renderer.domElement.addEventListener('mousedown', onMouseDown)

			// orbit controls
			controls = new OrbitControls(camera, renderer.domElement)
			controls.minPolarAngle = Math.PI * 0.15
			controls.maxPolarAngle = Math.PI * 0.35
			controls.minDistance = 8
			controls.maxDistance = 12
		}

		function animate() {
			// Render loop
			requestAnimationFrame(animate)

			// idleWeight = idleAction.getEffectiveWeight()
			// walkWeight = walkAction.getEffectiveWeight()
			// runWeight = runAction.getEffectiveWeight()

			// Enable/disable crossfade controls according to current weight values
			//	updateCrossFadeControls();

			// Get the time elapsed since the last frame, used for mixer update (if not in single step mode)
			var mixerUpdateDelta = clock.getDelta()

			// Update the animation mixer, the stats panel, and render this frame
			mixer.update(mixerUpdateDelta)

			renderer.render(scene, camera)
		}


		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight
			camera.updateProjectionMatrix()
			renderer.setSize(window.innerWidth, window.innerHeight)// new
		}

		function parseBigInt(value) {
			return Number(value.slice(0, -1))
		}

	</script>

</body>

</html>