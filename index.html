<!DOCTYPE html>
<html lang="en">

<head>
	<title>Memories</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

	<style>
		html,
		body {
			background: #111;
			color: #fff;
			padding: 0;
			margin: 0px;
			font-weight: bold;
			overflow: hidden;
			display: block;
		}

		#panel {
			position: absolute;
			top: 0%;
			left: 0%;
			width: 160px;
		}
	</style>
</head>

<body>


	<div id="container"></div>

	<!-- NEW WAY OF UPDATING AND IMPORTING THREE.JS -->
	<!-- Import maps polyfill -->
	<!-- Remove this when import maps will be widely supported -->
	<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

	<script type="importmap">
			{
				"imports": {
					"three": "./build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

	<script type="module">
		import * as THREE from 'three';
		import Stats from 'three/addons/libs/stats.module.js';
		import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
		import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
		import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';
		import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
		import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		import { HalftonePass } from 'three/addons/postprocessing/HalftonePass.js';

		var scene, controls, renderer, camera, stats;
		var model, skeleton, mixer, clock;
		var crossFadeControls = [];
		var idleAction, walkAction, runAction;
		var idleWeight, walkWeight, runWeight;
		var actions, settings;
		var singleStepMode = false;
		var sizeOfNextStep = 0;
		var composer;
		var pointLight;
		var uniforms;
		var geometry;
		var envMap;
		var m;
		var afterimagePass;
		var mixers = [];
		var isMouseDown = false;
		var params = {
			shape: 4,
			radius: 1,
			rotateR: 40.23,
			rotateB: 44.63,
			rotateG: 41.31,
			scatter: 1,
			blending: 0.63,
			blendingMode: 1,
			greyscale: true,
			disable: false
		};
		


		init();

		function init() {

			var container = document.getElementById('container');

			camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 100);
			camera.position.set(-4, 1, -9);

			clock = new THREE.Clock();
			scene = new THREE.Scene();

			scene.background = new THREE.Color(0xa0a0a0);
			scene.fog = new THREE.Fog(0xa0a0a0, 1, 20);

			// Colour Choices
			// 0x011B56 navy 
			// 0x0269A4 dark blue
			// 0x00B4AB Cyan green
			// 0xFFD832 Yellow
			// 0xFE7C00 orange 
			// 0xff8928 orange 2
			// 0xff414e Pink / red
			// 0xb7bdbb Grey / Blue
			// blue sky = 0x0077ff 
			// white part = 0xffffff
			// 0x87ceeb Sky Blue


			// LIGHTS
			var hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 3);
			hemiLight.color.setHSL(0.6, 1, 0.1);
			hemiLight.groundColor.setHSL(0.1, .1, 0.6);
			hemiLight.position.set(10, 70, 10);
			hemiLight.rotation.set(0, -30, 0);
			scene.add(hemiLight);
			// var hemiLightHelper = new THREE.HemisphereLightHelper( hemiLight, 1 );
			// scene.add( hemiLightHelper );

			var dirLight = new THREE.DirectionalLight(0xffffff, 1);
			dirLight.color.setHSL(0.1, .5, 1);
			dirLight.position.set(-5, 6, .01);
			dirLight.position.multiplyScalar(12);
			scene.add(dirLight);
			dirLight.castShadow = true;
			dirLight.shadow.mapSize.width = 512;
			dirLight.shadow.mapSize.height = 512;
			dirLight.intensity = 0.4;

			var d = 20;
			dirLight.shadow.camera.left = -d;
			dirLight.shadow.camera.right = d;
			dirLight.shadow.camera.top = d;
			dirLight.shadow.camera.bottom = -d;
			dirLight.shadow.camera.far = 150;
			dirLight.shadow.bias = -0.00001;
			// var dirLightHeper = new THREE.DirectionalLightHelper( dirLight, 10 );
			// scene.add( dirLightHeper );

			// Ground
			var mesh = new THREE.Mesh(new THREE.CircleGeometry(40, 40), new THREE.MeshPhongMaterial({
				color: 0x999999, depthWrite: true
			})); 
			mesh.rotation.x = - Math.PI / 2;
			mesh.position.y = -2.05;
			mesh.receiveShadow = true;
			scene.add(mesh);

			// 3D Model
			var loader = new GLTFLoader();
			loader.load('./gltf/Memories_animClips_V14.gltf', function (gltf) {

				var model = gltf.scene;
				gltf.scene.traverse(function (object) {

					if (object.isMesh) {

						//   console.log(object.name)
						var m = object.material;

						m.transparent = true;
						m.opacity = 0.5;
						m.DoubleSided = true;
						object.material = object.material.clone();
				
						const rColor = () => Math.floor((Math.random() * 255))
						object.material.color = new THREE.Color(`rgb(${rColor()}, ${rColor()}, ${rColor()})`);
						object.castShadow = true;
						object.receiveShadow = true;
					}

					model.position.set(0, -2.2, 0);
					model.rotation.set(0, -3.1, 0);
					model.scale.set(.025, .025, .025);
					scene.add(model);
				});


				// Skeleton
				skeleton = new THREE.SkeletonHelper(model);
				skeleton.visible = false;
				scene.add(skeleton);
				createPanel();

				// Animation
				var animations = gltf.animations;
				//	console.log(gltf.animations);

				mixer = new THREE.AnimationMixer(model);

				idleAction = mixer.clipAction(animations[1]);
				walkAction = mixer.clipAction(animations[0]);
				runAction = mixer.clipAction(animations[2]);
				actions = [idleAction, walkAction, runAction];
				activateAllActions();

				animate();

			});

			// Rendering	
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.outputEncoding = THREE.sRGBEncoding;
			renderer.toneMapping = THREE.ReinhardToneMapping; 
			//renderer.shadowMap.enabled = true;
			container.appendChild(renderer.domElement);
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.PCFSoftShadowMap; 

			// Event Listeners	
			window.addEventListener('resize', onWindowResize, false);
			renderer.domElement.addEventListener('mousedown', onMouseDown);

			// orbit controls
			controls = new OrbitControls(camera, renderer.domElement);
			controls.minPolarAngle = Math.PI * 0.15;
			controls.maxPolarAngle = Math.PI * 0.35;
			controls.minDistance = 8;
			controls.maxDistance = 12;

			// post-processing
			composer = new EffectComposer(renderer);
			var renderPass = new RenderPass(scene, camera);
			const halftonePass = new HalftonePass(window.innerWidth, window.innerHeight, params);
			composer.addPass(renderPass);
			composer.addPass(halftonePass);

		} // end of init


		// GUI
		function createPanel() {

			var panel = new GUI({}); // , width: 200
			panel.domElement.id = 'panel';

			//var folder1 = panel.addFolder( 'Visibility' );
			//var folder2 = panel.addFolder( 'Activation/Deactivation' );
			//var folder3 = panel.addFolder( 'Pausing/Stepping' );
			var folder4 = panel.addFolder('Nostalgia');
			//var folder5 = panel.addFolder( 'Blend Weights' );
			var folder6 = panel.addFolder('Time');

			settings = {
				'show model': true,
				'show skeleton': false,
				'deactivate all': deactivateAllActions,
				'activate all': activateAllActions,
				//'pause/continue': pauseContinue,
				'make single step': toSingleStepMode,
				'modify step size': 0.05,

				'Memory': function () {
					prepareCrossFade(idleAction, walkAction, 1.0);
				},

				'Fade': function () {
					prepareCrossFade(walkAction, idleAction, 0.5);
				},

				'from walk to run': function () {
					prepareCrossFade(walkAction, runAction, 2.5);
				},

				'from run to walk': function () {
					prepareCrossFade(runAction, walkAction, 5.0);
				},

				'use default duration': true,
				'set custom duration': 3.5,
				'modify idle weight': 0.0,
				'modify walk weight': 1.0,
				'modify run weight': 0.0,
				'Slow Down': 0.7
			};

			//folder1.add( settings, 'show model' ).onChange( showModel );
			//folder1.add( settings, 'show skeleton' ).onChange( showSkeleton );
			//folder2.add( settings, 'deactivate all' );
			//folder2.add( settings, 'activate all' );
			//folder3.add( settings, 'pause/continue' );
			//	folder3.add( settings, 'make single step' );
			//folder3.add( settings, 'modify step size', 0.01, 0.1, 0.001 );
			crossFadeControls.push(folder4.add(settings, 'Memory'));
			crossFadeControls.push(folder4.add(settings, 'Fade'));
			//	crossFadeControls.push( folder4.add( settings, 'from walk to run' ) );
			//	crossFadeControls.push( folder4.add( settings, 'from run to walk' ) );
			//folder4.add( settings, 'use default duration' );
			//folder4.add( settings, 'set custom duration', 0, 10, 0.01 );

			/*folder5.add( settings, 'modify idle weight', 0.0, 1.0, 0.01 ).listen().onChange( function ( weight ) {
				setWeight( idleAction, weight );
			} );
		    
			folder5.add( settings, 'modify walk weight', 0.0, 1.0, 0.01 ).listen().onChange( function ( weight ) {
				setWeight( walkAction, weight );
			} );
		    
			folder5.add( settings, 'modify run weight', 0.0, 1.0, 0.01 ).listen().onChange( function ( weight ) {
				setWeight( runAction, weight );
			} );*/

			folder6.add(settings, 'Slow Down', 0.0, 0.7, 0.01).onChange(Speed);

			//folder1.open();
			//folder2.open();
			//	folder3.open();
			folder4.open();
			//folder5.open();
			folder6.open();
			panel.close();

			// crossFadeControls.forEach( function ( control ) {

			// 	control.classList1 = control.domElement.parentElement.parentElement.classList;
			// 	control.classList2 = control.domElement.previousElementSibling.classList;

			// 	control.setDisabled = function () {

			// 		control.classList1.add( 'no-pointer-events' );
			// 		control.classList2.add( 'control-disabled' );

			// 	};

			// 	control.setEnabled = function () {

			// 		control.classList1.remove( 'no-pointer-events' );
			// 		control.classList2.remove( 'control-disabled' );

			// 	};

			// } );

		}

		/*	function showModel( visibility ) {
				model.visible = visibility;
			}

			function showSkeleton( visibility ) {
				skeleton.visible = visibility;
			}*/


		function Speed(speed) {
			mixer.timeScale = speed;
		}


		function deactivateAllActions() {

			actions.forEach(function (action) {

				action.stop();

			});

		}

		function activateAllActions() {
			setWeight(idleAction, settings['modify idle weight']);
			setWeight(walkAction, settings['modify walk weight']);
			setWeight(runAction, settings['modify run weight']);
			actions.forEach(function (action) {
				action.play();
			});
		}

		function pauseContinue() {

			if (singleStepMode) {
				singleStepMode = false;
				unPauseAllActions();

			} else {
				if (idleAction.paused) {
					unPauseAllActions();

				} else {
					pauseAllActions();
				}
			}
		}

		function pauseAllActions() {
			actions.forEach(function (action) {
				action.paused = true;
			});
		}

		function unPauseAllActions() {
			actions.forEach(function (action) {
				action.paused = false;
			});
		}

		function toSingleStepMode() {
			unPauseAllActions();
			singleStepMode = true;
			sizeOfNextStep = settings['modify step size'];
		}

		function prepareCrossFade(startAction, endAction, defaultDuration) {

			// Switch default / custom crossfade duration (according to the user's choice)
			var duration = setCrossFadeDuration(defaultDuration);

			// Make sure that we don't go on in singleStepMode, and that all actions are unpaused
			singleStepMode = false;
			unPauseAllActions();

			// If the current action is 'idle' (duration 4 sec), execute the crossfade immediately;
			// else wait until the current action has finished its current loop
			if (startAction === idleAction) {
				executeCrossFade(startAction, endAction, duration);
			} else {
				synchronizeCrossFade(startAction, endAction, duration);
			}
		}

		function setCrossFadeDuration(defaultDuration) {
			// Switch default crossfade duration <-> custom crossfade duration
			if (settings['use default duration']) {
				return defaultDuration;
			} else {
				return settings['set custom duration'];
			}
		}

		function synchronizeCrossFade(startAction, endAction, duration) {
			mixer.addEventListener('loop', onLoopFinished);
			function onLoopFinished(event) {
				if (event.action === startAction) {
					mixer.removeEventListener('loop', onLoopFinished);
					executeCrossFade(startAction, endAction, duration);
				}
			}
		}

		function executeCrossFade(startAction, endAction, duration) {

			// Not only the start action, but also the end action must get a weight of 1 before fading
			// (concerning the start action this is already guaranteed in this place)
			setWeight(endAction, 1);
			endAction.time = 0;

			// Crossfade with warping - you can also try without warping by setting the third parameter to false
			startAction.crossFadeTo(endAction, duration, true);
		}

		// This function is needed, since animationAction.crossFadeTo() disables its start action and sets
		// the start action's timeScale to ((start animation's duration) / (end animation's duration))
		function setWeight(action, weight) {
			action.enabled = true;
			action.setEffectiveTimeScale(1);
			action.setEffectiveWeight(weight);

		}

		// Called by the render loop
		function updateWeightSliders() {
			settings['modify idle weight'] = idleWeight;
			settings['modify walk weight'] = walkWeight;
			settings['modify run weight'] = runWeight;
		}

		// Called by the render loop
		// function updateCrossFadeControls() {
		// 	crossFadeControls.forEach( function ( control ) {
		// 		control.setDisabled();
		// 	} );

		// 	if ( idleWeight === 1 && walkWeight === 0 && runWeight === 0 ) {
		// 		crossFadeControls[ 1 ].setEnabled();
		// 	}

		// 	if ( idleWeight === 0 && walkWeight === 1 && runWeight === 0 ) {
		// 		crossFadeControls[ 0 ].setEnabled();
		// 		crossFadeControls[ 2 ].setEnabled();
		// 	}

		// 	if ( idleWeight === 0 && walkWeight === 0 && runWeight === 1 ) {
		// 		crossFadeControls[ 3 ].setEnabled();
		// 	}

		// }

		function onMouseDown() {
			isMouseDown = true;
		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
			composer.setSize(window.innerWidth, window.innerHeight); // new
		}



		function animate() {
			// Render loop
			requestAnimationFrame(animate);

			idleWeight = idleAction.getEffectiveWeight();
			walkWeight = walkAction.getEffectiveWeight();
			runWeight = runAction.getEffectiveWeight();

			// Update the panel values if weights are modified from "outside" (by crossfadings)
			updateWeightSliders();

			// Enable/disable crossfade controls according to current weight values
			//	updateCrossFadeControls();

			// Get the time elapsed since the last frame, used for mixer update (if not in single step mode)
			var mixerUpdateDelta = clock.getDelta();

			// If in single step mode, make one step and then do nothing (until the user clicks again)
			if (singleStepMode) {
				mixerUpdateDelta = sizeOfNextStep;
				sizeOfNextStep = 0;
			}

			// Update the animation mixer, the stats panel, and render this frame
			mixer.update(mixerUpdateDelta);

			// Get the time elapsed since the last frame
			var mixerUpdateDelta = clock.getDelta();

			// Update all the animation frames
			for (var i = 0; i < mixers.length; ++i) {
				mixers[i].update(mixerUpdateDelta);
			}

			if (!isMouseDown) {
				// camera.position.z = 25;
				// camera.rotation.y = Math.sin( Date.now() * 0.0004 ) * 0.8;
				// camera.position.x = Math.sin( Date.now() * 0.0003 ) +- 0.01;
				// camera.rotation.z += 0.001;
				// camera.position.y -= 0.02;
				// camera.position.z -= 0.05; 
				// scene.rotation.y = ( Date.now() * 0.0001 * 0.3 );
			}

			//stats.update();
			// var renderPass = new RenderPass( scene, camera );
			// var composer = new EffectComposer( scene, camera );

			composer.render();
			// renderer.render( scene, camera );


		}

	</script>

</body>

</html>